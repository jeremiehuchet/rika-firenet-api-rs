/*
 * Rika Firenet - OpenAPI 3.0
 *
 * Rika Firenet API operations
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, configuration};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for passing parameters to the method [`stove_controls`]
#[derive(Clone, Debug)]
pub struct StoveControlsParams {
    /// Stove identifier
    pub stove_id: String,
    pub room_power_request: Option<i32>,
    pub bake_temperature: Option<String>,
    pub convection_fan1_active: Option<bool>,
    pub convection_fan1_area: Option<i32>,
    pub convection_fan1_level: Option<i32>,
    pub convection_fan2_active: Option<bool>,
    pub convection_fan2_area: Option<i32>,
    pub convection_fan2_level: Option<i32>,
    pub debug0: Option<i32>,
    pub debug1: Option<i32>,
    pub debug2: Option<i32>,
    pub debug3: Option<i32>,
    pub debug4: Option<i32>,
    pub eco_mode: Option<bool>,
    pub frost_protection_active: Option<bool>,
    pub frost_protection_temperature: Option<String>,
    pub heating_power: Option<i32>,
    pub heating_time_fri1: Option<String>,
    pub heating_time_fri2: Option<String>,
    pub heating_time_mon1: Option<String>,
    pub heating_time_mon2: Option<String>,
    pub heating_time_sat1: Option<String>,
    pub heating_time_sat2: Option<String>,
    pub heating_time_sun1: Option<String>,
    pub heating_time_sun2: Option<String>,
    pub heating_time_thu1: Option<String>,
    pub heating_time_thu2: Option<String>,
    pub heating_time_tue1: Option<String>,
    pub heating_time_tue2: Option<String>,
    pub heating_time_wed1: Option<String>,
    pub heating_time_wed2: Option<String>,
    pub heating_times_active_for_comfort: Option<bool>,
    pub on_off: Option<bool>,
    pub operating_mode: Option<i32>,
    pub revision: Option<i32>,
    pub set_back_temperature: Option<String>,
    pub target_temperature: Option<String>,
    pub temperature_offset: Option<String>,
}

/// struct for passing parameters to the method [`stove_status`]
#[derive(Clone, Debug)]
pub struct StoveStatusParams {
    /// Stove identifier
    pub stove_id: String,
}

/// struct for typed errors of method [`list_stoves`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListStovesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stove_controls`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoveControlsError {
    Status404(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stove_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoveStatusError {
    Status401(String),
    Status500(String),
    UnknownValue(serde_json::Value),
}

pub async fn list_stoves(
    configuration: &configuration::Configuration,
) -> Result<String, Error<ListStovesError>> {
    let uri_str = format!("{}/web/summary", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Ok(content),
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `String`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListStovesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn stove_controls(
    configuration: &configuration::Configuration,
    params: StoveControlsParams,
) -> Result<(), Error<StoveControlsError>> {
    let uri_str = format!(
        "{}/api/client/{stoveId}/controls",
        configuration.base_path,
        stoveId = crate::apis::urlencode(params.stove_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.room_power_request {
        multipart_form_params.insert("RoomPowerRequest", param_value.to_string());
    }
    if let Some(param_value) = params.bake_temperature {
        multipart_form_params.insert("bakeTemperature", param_value.to_string());
    }
    if let Some(param_value) = params.convection_fan1_active {
        multipart_form_params.insert("convectionFan1Active", param_value.to_string());
    }
    if let Some(param_value) = params.convection_fan1_area {
        multipart_form_params.insert("convectionFan1Area", param_value.to_string());
    }
    if let Some(param_value) = params.convection_fan1_level {
        multipart_form_params.insert("convectionFan1Level", param_value.to_string());
    }
    if let Some(param_value) = params.convection_fan2_active {
        multipart_form_params.insert("convectionFan2Active", param_value.to_string());
    }
    if let Some(param_value) = params.convection_fan2_area {
        multipart_form_params.insert("convectionFan2Area", param_value.to_string());
    }
    if let Some(param_value) = params.convection_fan2_level {
        multipart_form_params.insert("convectionFan2Level", param_value.to_string());
    }
    if let Some(param_value) = params.debug0 {
        multipart_form_params.insert("debug0", param_value.to_string());
    }
    if let Some(param_value) = params.debug1 {
        multipart_form_params.insert("debug1", param_value.to_string());
    }
    if let Some(param_value) = params.debug2 {
        multipart_form_params.insert("debug2", param_value.to_string());
    }
    if let Some(param_value) = params.debug3 {
        multipart_form_params.insert("debug3", param_value.to_string());
    }
    if let Some(param_value) = params.debug4 {
        multipart_form_params.insert("debug4", param_value.to_string());
    }
    if let Some(param_value) = params.eco_mode {
        multipart_form_params.insert("ecoMode", param_value.to_string());
    }
    if let Some(param_value) = params.frost_protection_active {
        multipart_form_params.insert("frostProtectionActive", param_value.to_string());
    }
    if let Some(param_value) = params.frost_protection_temperature {
        multipart_form_params.insert("frostProtectionTemperature", param_value.to_string());
    }
    if let Some(param_value) = params.heating_power {
        multipart_form_params.insert("heatingPower", param_value.to_string());
    }
    if let Some(param_value) = params.heating_time_fri1 {
        multipart_form_params.insert("heatingTimeFri1", param_value.to_string());
    }
    if let Some(param_value) = params.heating_time_fri2 {
        multipart_form_params.insert("heatingTimeFri2", param_value.to_string());
    }
    if let Some(param_value) = params.heating_time_mon1 {
        multipart_form_params.insert("heatingTimeMon1", param_value.to_string());
    }
    if let Some(param_value) = params.heating_time_mon2 {
        multipart_form_params.insert("heatingTimeMon2", param_value.to_string());
    }
    if let Some(param_value) = params.heating_time_sat1 {
        multipart_form_params.insert("heatingTimeSat1", param_value.to_string());
    }
    if let Some(param_value) = params.heating_time_sat2 {
        multipart_form_params.insert("heatingTimeSat2", param_value.to_string());
    }
    if let Some(param_value) = params.heating_time_sun1 {
        multipart_form_params.insert("heatingTimeSun1", param_value.to_string());
    }
    if let Some(param_value) = params.heating_time_sun2 {
        multipart_form_params.insert("heatingTimeSun2", param_value.to_string());
    }
    if let Some(param_value) = params.heating_time_thu1 {
        multipart_form_params.insert("heatingTimeThu1", param_value.to_string());
    }
    if let Some(param_value) = params.heating_time_thu2 {
        multipart_form_params.insert("heatingTimeThu2", param_value.to_string());
    }
    if let Some(param_value) = params.heating_time_tue1 {
        multipart_form_params.insert("heatingTimeTue1", param_value.to_string());
    }
    if let Some(param_value) = params.heating_time_tue2 {
        multipart_form_params.insert("heatingTimeTue2", param_value.to_string());
    }
    if let Some(param_value) = params.heating_time_wed1 {
        multipart_form_params.insert("heatingTimeWed1", param_value.to_string());
    }
    if let Some(param_value) = params.heating_time_wed2 {
        multipart_form_params.insert("heatingTimeWed2", param_value.to_string());
    }
    if let Some(param_value) = params.heating_times_active_for_comfort {
        multipart_form_params.insert("heatingTimesActiveForComfort", param_value.to_string());
    }
    if let Some(param_value) = params.on_off {
        multipart_form_params.insert("onOff", param_value.to_string());
    }
    if let Some(param_value) = params.operating_mode {
        multipart_form_params.insert("operatingMode", param_value.to_string());
    }
    if let Some(param_value) = params.revision {
        multipart_form_params.insert("revision", param_value.to_string());
    }
    if let Some(param_value) = params.set_back_temperature {
        multipart_form_params.insert("setBackTemperature", param_value.to_string());
    }
    if let Some(param_value) = params.target_temperature {
        multipart_form_params.insert("targetTemperature", param_value.to_string());
    }
    if let Some(param_value) = params.temperature_offset {
        multipart_form_params.insert("temperatureOffset", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StoveControlsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn stove_status(
    configuration: &configuration::Configuration,
    params: StoveStatusParams,
) -> Result<models::StoveStatus, Error<StoveStatusError>> {
    let uri_str = format!(
        "{}/api/client/{stoveId}/status",
        configuration.base_path,
        stoveId = crate::apis::urlencode(params.stove_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::StoveStatus`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::StoveStatus`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoveStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
